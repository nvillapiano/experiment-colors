html, body {
    overflow: hidden;
}

.speakers {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
}

.speaker {
    @include absolute-center;
    background: black;
    border-radius: 50%;     

    &.animate {
        animation: undulate 5s infinite;
    }
}

$totalElements: 20;

@for $i from 1 through $totalElements {

    $hueVariance: $i * 10;
    $color: blue - ($hueVariance);
    $color2: red - ($hueVariance); 

    .speaker:nth-of-type(#{$i}) {
        // Basically growing each element at an incremental rate. 
        // The + $totalElements is to make sure we're fully filling the viewport. 
        // The output of this math is more or less just an incrementally climbing percentage, in this case going from 12vmin -> 240vmin.
        width: ( .1 * $i * (100 + $totalElements) ) + vmin;
        height: ( .1 * $i * (100 + $totalElements) ) + vmin;
        // Incremental increase in animation delay. Makes the cool ripple effect.
        animation-delay: 0.0s + ($i / $totalElements);
        // Properly layering the dom elements.
        z-index: $totalElements + 1 - $i;
    }

    // Just going incrementally from color one to color2 and back. Also aids in the cool ripple effect.
    @keyframes undulate {
        0% {
            background: $color + ($hueVariance);      
        }

        50% {
            background: $color2 + ($hueVariance); 
        }

        100% {
            background: $color + ($hueVariance);  
        }
    }         
}

// TODO: Animating background color is expensive. 
// Explore absolutely positioning a pseudo element on top of each dom and animating opacity instead.
