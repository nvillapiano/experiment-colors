html, body {
    overflow: hidden;
}

.speakers {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
}

.speaker {
    @include absolute-center;
    background: black;
    border-radius: 50%;

    &.animate {
        animation: colorFade 5s infinite;
    }
}

$totalElements: 20;
// $hueVariance: $i * 10;
$color: blue;
$color2: red;

@for $i from 1 through $totalElements {

    .speaker:nth-of-type(#{$i}) {
        // Basically growing each element at an incremental rate.
        // The + $totalElements is to make sure we're fully filling the viewport.
        // The output of this math is more or less just an incrementally climbing percentage, in this case going from 12vmin -> 240vmin.
        width: ( .1 * $i * (100 + $totalElements) ) + vmin;
        height: ( .1 * $i * (100 + $totalElements) ) + vmin;
        // Incremental increase in animation delay. Makes the cool ripple effect.
        animation-delay: 0.0s + ($i / $totalElements);
        // Properly layering the dom elements.
        z-index: $totalElements + 1 - $i;
    }
}

@keyframes colorFade {
    0% {
        background: $color;
    }

    50% {
        background: $color2;
    }

    100% {
        background: $color;
    }
}

// TODO: Animating background color is expensive.
// Explore absolutely positioning a pseudo element on top of each dom and animating opacity instead.
